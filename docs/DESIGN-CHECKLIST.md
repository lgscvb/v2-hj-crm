# 設計審查 Checklist

> 每個新功能開發前，必須回答以下問題

---

## 1. 業務事件識別 (Domain Event Check)

### 這是 CRUD 還是業務事件？

| 類型 | 特徵 | 處理方式 |
|------|------|---------|
| **簡單 CRUD** | 只改一個欄位、無連鎖反應 | 前端直接呼叫 PostgREST |
| **業務事件** | 涉及多表、有連鎖反應、狀態流轉 | 封裝為 MCP Tool |

### 問自己：

- [ ] 這個操作會影響幾張表？（> 1 張 = 業務事件）
- [ ] 這個操作會觸發其他動作嗎？（產生帳款、發通知 = 業務事件）
- [ ] 這個操作涉及狀態變化嗎？（draft → active = 業務事件）

**範例**：
- ❌ 「更新客戶電話」→ 簡單 CRUD
- ✅ 「續約」→ 業務事件（涉及：舊合約、新合約、應收帳款）

---

## 2. 交易完整性 (Transaction Integrity)

### 如果中間斷網會怎樣？

對於每個業務事件，畫出步驟並標記危險點：

```
步驟 1: 建立新合約
        ↓
   ⚠️ 斷網點 ⚠️  ← 這裡斷了會怎樣？
        ↓
步驟 2: 更新舊合約
```

### 問自己：

- [ ] 中間失敗會產生「半成品」資料嗎？
- [ ] 使用者 F5 重整會產生重複資料嗎？
- [ ] 這些操作需要「全有或全無」嗎？

**解法選擇**：

| 場景 | 解法 |
|------|------|
| 多表操作需同步 | PostgreSQL Transaction / Function |
| 操作可能 Timeout | 兩階段提交（Draft → Activate） |
| 可能重複提交 | Idempotency Key |

---

## 3. 責任邊界 (Responsibility Boundary)

### 前端該做什麼？後端該做什麼？

| 層級 | 職責 | 不該做的事 |
|------|------|-----------|
| **前端** | 收集輸入、顯示結果、發送意圖 | 計算業務邏輯、決定狀態流轉 |
| **後端** | 驗證、計算、狀態管理、資料一致性 | 只當 CRUD proxy |

### 問自己：

- [ ] 前端有沒有在「決定」業務邏輯？
- [ ] 如果前端壞掉，後端能獨立完成操作嗎？
- [ ] 前端對後端的呼叫是「一個意圖一個 API」嗎？

**危險信號**：
- 前端需要呼叫 2+ 個 API 才能完成一個操作 ⚠️
- 前端在 if/else 判斷業務規則 ⚠️
- 前端知道資料表結構細節 ⚠️

---

## 4. 狀態流轉圖 (State Machine)

對於有狀態的實體（合約、案件），必須畫出狀態圖：

```
           建立
             ↓
        ┌─────────┐
        │  draft  │
        └────┬────┘
             │ activate()
             ↓
        ┌─────────┐
        │ active  │←────────┐
        └────┬────┘         │
             │              │ 續約
    ┌────────┼────────┐     │
    ↓        ↓        ↓     │
┌───────┐ ┌───────┐ ┌───────┴──┐
│expired│ │renewed│ │terminated│
└───────┘ └───────┘ └──────────┘
```

### 問自己：

- [ ] 每個狀態轉換都有明確的「觸發條件」嗎？
- [ ] 有沒有非法的轉換路徑？
- [ ] 狀態檢查是在後端還是前端？（必須在後端）

---

## 5. 技術債管理 (Tech Debt)

### 新舊系統並存時

- [ ] 新功能是否需要讀取舊欄位？
- [ ] 舊欄位何時可以廢棄？
- [ ] 有沒有 Migration 計畫？

**規則**：
1. 新功能只用新結構
2. 舊視圖/API 加上 `@deprecated` 標記
3. 設定廢棄時間點並寫入文件

---

## 6. 事前驗屍 (Pre-mortem)

在開發前，假設這個功能「三個月後爛掉了」，問：

> 「它是怎麼死的？」

常見死法：
- [ ] 網路斷了，資料只存一半
- [ ] 使用者重複點擊，產生重複資料
- [ ] 並發操作，資料互相覆蓋
- [ ] 狀態不一致，業務流程卡住

---

## 設計文件模板

每個中大型功能必須包含：

```markdown
## 功能名稱

### 1. 業務事件
- 涉及實體：[列出]
- 連鎖反應：[列出]

### 2. 狀態流轉圖
[Mermaid 圖]

### 3. 交易邊界
- Transaction 範圍：[描述]
- 失敗回滾策略：[描述]

### 4. API 設計
- 前端發送：一個請求
- 後端處理：封裝全部邏輯

### 5. 邊界情況
- Timeout 處理：[描述]
- 重複提交處理：[描述]
```

---

## 審查紅旗 (Red Flags)

遇到以下情況，必須停下來重新設計：

| 紅旗 | 問題 |
|------|------|
| 前端需要連續呼叫 2+ API | 缺少後端封裝 |
| 業務邏輯在 useEffect 裡 | 邏輯洩漏到前端 |
| 沒有 Transaction 的多表操作 | 資料一致性風險 |
| 新舊欄位都在用 | 技術債累積 |
| 狀態轉換沒有後端驗證 | 狀態可被繞過 |

---

## 本專案已踩過的坑

| 功能 | 問題 | 解法 | 文件 |
|------|------|------|------|
| 續約流程 | Checklist 只改欄位，沒建新合約 | 兩階段提交 + Transaction | [SSD-v1.5](SSD-v1.5-renewal-draft.md) |
| 解約流程 | 多表操作無 Transaction | ⏳ 待修復 | [PRD-v2.5](PRD-v2.5-data-consistency.md) |
| 發票開立 | 外部 API 成功但本地更新失敗 | ⏳ 待修復 | [PRD-v2.5](PRD-v2.5-data-consistency.md) |
